{"version":3,"sources":["../src/index.ts","../src/streams/assistant-response.ts","../src/lib/copilotkit-runtime.ts","../src/utils/openai.ts","../src/utils/stream.ts","../src/utils/langserve.ts","../src/lib/copilot-cloud.ts","../src/lib/openai-adapter.ts","../src/lib/langchain-adapter.ts","../src/lib/openai-assistant-adapter.ts"],"sourcesContent":["export * from \"./streams\";\nexport * from \"./types\";\nexport * from \"./lib\";\nexport { inferLangServeParameters } from \"./utils/langserve\";\n","import { AssistantMessage, formatStreamPart } from \"@copilotkit/shared\";\n\nexport function experimental_AssistantResponse(\n  { threadId, messageId }: { threadId: string; messageId: string },\n  process: (stream: {\n    threadId: string;\n    messageId: string;\n    sendMessage: (message: AssistantMessage) => void;\n  }) => Promise<void>,\n): Response {\n  const stream = new ReadableStream({\n    async start(controller): Promise<void> {\n      const textEncoder = new TextEncoder();\n\n      const sendMessage = (message: AssistantMessage) => {\n        controller.enqueue(textEncoder.encode(formatStreamPart(\"assistant_message\", message)));\n      };\n\n      const sendError = (errorMessage: string) => {\n        controller.enqueue(textEncoder.encode(formatStreamPart(\"error\", errorMessage)));\n      };\n\n      // send the threadId and messageId as the first message:\n      controller.enqueue(\n        textEncoder.encode(\n          formatStreamPart(\"assistant_control_data\", {\n            threadId,\n            messageId,\n          }),\n        ),\n      );\n\n      try {\n        await process({\n          threadId,\n          messageId,\n          sendMessage,\n        });\n      } catch (error) {\n        sendError((error as any).message ?? `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {},\n    cancel() {},\n  });\n\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n","import {\n  Action,\n  ToolDefinition,\n  EXCLUDE_FROM_FORWARD_PROPS_KEYS,\n  actionToChatCompletionFunction,\n  Parameter,\n  AnnotatedFunction,\n  annotatedFunctionToAction,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  CopilotCloudConfig,\n} from \"@copilotkit/shared\";\nimport {\n  SingleChunkReadableStream,\n  copilotkitStreamInterceptor,\n  remoteChainToAction,\n} from \"../utils\";\nimport { RemoteChain, CopilotKitServiceAdapter } from \"../types\";\nimport { CopilotCloud, RemoteCopilotCloud } from \"./copilot-cloud\";\n\ninterface CopilotRuntimeResult {\n  stream: ReadableStream;\n  headers?: Record<string, string>;\n}\n\ninterface CopilotRuntimeConstructorParams<T extends Parameter[] | [] = []> {\n  actions?: Action<T>[];\n  langserve?: RemoteChain[];\n  debug?: boolean;\n  copilotCloud?: CopilotCloud;\n}\n\ninterface CopilotDeprecatedRuntimeConstructorParams<T extends Parameter[] | [] = []> {\n  actions?: AnnotatedFunction<any>[];\n  langserve?: RemoteChain[];\n  debug?: boolean;\n  copilotCloud?: CopilotCloud;\n}\n\nexport class CopilotRuntime<const T extends Parameter[] | [] = []> {\n  private actions: Action<any>[] = [];\n  private langserve: Promise<Action<any>>[] = [];\n  private debug: boolean = false;\n  private copilotCloud: CopilotCloud;\n\n  constructor(params?: CopilotRuntimeConstructorParams<T>);\n  // @deprecated use Action<T> instead of AnnotatedFunction<T>\n  constructor(params?: CopilotDeprecatedRuntimeConstructorParams<T>);\n  constructor(\n    params?: CopilotRuntimeConstructorParams<T> | CopilotDeprecatedRuntimeConstructorParams<T>,\n  ) {\n    for (const action of params?.actions || []) {\n      if (\"argumentAnnotations\" in action) {\n        this.actions.push(annotatedFunctionToAction(action));\n      } else {\n        this.actions.push(action);\n      }\n    }\n    for (const chain of params?.langserve || []) {\n      this.langserve.push(remoteChainToAction(chain));\n    }\n    this.debug = params?.debug || false;\n    this.copilotCloud = params?.copilotCloud || new RemoteCopilotCloud();\n  }\n\n  addAction<const T extends Parameter[] | [] = []>(action: Action<T>): void;\n  /** @deprecated Use addAction with Action<T> instead. */\n  addAction(action: AnnotatedFunction<any>): void;\n  addAction<const T extends Parameter[] | [] = []>(\n    action: Action<T> | AnnotatedFunction<any>,\n  ): void {\n    this.removeAction(action.name);\n    if (\"argumentAnnotations\" in action) {\n      this.actions.push(annotatedFunctionToAction(action));\n    } else {\n      this.actions.push(action);\n    }\n  }\n\n  removeAction(actionName: string): void {\n    this.actions = this.actions.filter((f) => f.name !== actionName);\n  }\n\n  removeBackendOnlyProps(forwardedProps: any): void {\n    // Get keys backendOnlyPropsKeys in order to remove them from the forwardedProps\n    const backendOnlyPropsKeys = forwardedProps[EXCLUDE_FROM_FORWARD_PROPS_KEYS];\n    if (Array.isArray(backendOnlyPropsKeys)) {\n      backendOnlyPropsKeys.forEach((key) => {\n        const success = Reflect.deleteProperty(forwardedProps, key);\n        if (!success) {\n          console.error(`Failed to delete property ${key}`);\n        }\n      });\n      // After deleting individual backend-only properties, delete the EXCLUDE_FROM_FORWARD_PROPS_KEYS property itself from forwardedProps\n      const success = Reflect.deleteProperty(forwardedProps, EXCLUDE_FROM_FORWARD_PROPS_KEYS);\n      if (!success) {\n        console.error(`Failed to delete EXCLUDE_FROM_FORWARD_PROPS_KEYS`);\n      }\n    } else if (backendOnlyPropsKeys) {\n      console.error(\"backendOnlyPropsKeys is not an array\");\n    }\n  }\n\n  private async getResponse(\n    forwardedProps: any,\n    serviceAdapter: CopilotKitServiceAdapter,\n    publicApiKey?: string,\n  ): Promise<CopilotRuntimeResult> {\n    this.removeBackendOnlyProps(forwardedProps);\n\n    // In case Copilot Cloud is configured remove it from the forwardedProps\n    const cloud: CopilotCloudConfig = forwardedProps.cloud;\n    delete forwardedProps.cloud;\n\n    const langserveFunctions: Action<any>[] = [];\n\n    for (const chainPromise of this.langserve) {\n      try {\n        const chain = await chainPromise;\n        langserveFunctions.push(chain);\n      } catch (error) {\n        console.error(\"Error loading langserve chain:\", error);\n      }\n    }\n\n    const serversideTools: Action<any>[] = [...this.actions, ...langserveFunctions];\n    const mergedTools = flattenToolCallsNoDuplicates([\n      ...serversideTools.map(actionToChatCompletionFunction),\n      ...(forwardedProps.tools || []),\n    ]);\n\n    try {\n      const result = await serviceAdapter.getResponse({\n        ...forwardedProps,\n        tools: mergedTools,\n      });\n\n      if (publicApiKey !== undefined) {\n        // wait for the cloud log chat to finish before streaming back the response\n        try {\n          const checkGuardrailsInputResult = await this.copilotCloud.checkGuardrailsInput({\n            cloud,\n            publicApiKey,\n            messages: forwardedProps.messages || [],\n          });\n\n          if (checkGuardrailsInputResult.status === \"denied\") {\n            // the chat was denied. instead of streaming back the response,\n            // we let the client know...\n            return {\n              stream: new SingleChunkReadableStream(checkGuardrailsInputResult.reason),\n              headers: result.headers,\n            };\n          }\n        } catch (error) {\n          console.error(\"Error checking guardrails:\", error);\n        }\n      }\n      const stream = copilotkitStreamInterceptor(result.stream, serversideTools, this.debug);\n      return { stream, headers: result.headers };\n    } catch (error) {\n      console.error(\"Error getting response:\", error);\n      throw error;\n    }\n  }\n\n  async response(req: Request, serviceAdapter: CopilotKitServiceAdapter): Promise<Response> {\n    const publicApiKey = req.headers.get(COPILOT_CLOUD_PUBLIC_API_KEY_HEADER) || undefined;\n    try {\n      const forwardedProps = await req.json();\n      const response = await this.getResponse(forwardedProps, serviceAdapter, publicApiKey);\n      return new Response(response.stream, { headers: response.headers });\n    } catch (error: any) {\n      return new Response(error, { status: error.status });\n    }\n  }\n\n  async streamHttpServerResponse(\n    req: any,\n    res: any,\n    serviceAdapter: CopilotKitServiceAdapter,\n    headers?: Record<string, string>,\n  ) {\n    const bodyParser = new Promise<any>((resolve, reject) => {\n      if (\"body\" in req) {\n        resolve(req.body);\n        return;\n      }\n      let body = \"\";\n      req.on(\"data\", (chunk: any) => (body += chunk.toString()));\n      req.on(\"end\", () => {\n        try {\n          resolve(JSON.parse(body));\n        } catch (error) {\n          reject(error);\n        }\n      });\n    });\n    const forwardedProps = await bodyParser;\n    const publicApiKey =\n      (req.header\n        ? // use header() in express\n          req.header(COPILOT_CLOUD_PUBLIC_API_KEY_HEADER)\n        : // use headers in node http\n          req.headers[COPILOT_CLOUD_PUBLIC_API_KEY_HEADER.toLowerCase()]) || undefined;\n    const response = await this.getResponse(forwardedProps, serviceAdapter, publicApiKey);\n    const mergedHeaders = { ...headers, ...response.headers };\n    res.writeHead(200, mergedHeaders);\n    const stream = response.stream;\n    const reader = stream.getReader();\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        res.end();\n        break;\n      } else {\n        res.write(new TextDecoder().decode(value));\n      }\n    }\n  }\n}\n\nexport function flattenToolCallsNoDuplicates(toolsByPriority: ToolDefinition[]): ToolDefinition[] {\n  let allTools: ToolDefinition[] = [];\n  const allToolNames: string[] = [];\n  for (const tool of toolsByPriority) {\n    if (!allToolNames.includes(tool.function.name)) {\n      allTools.push(tool);\n      allToolNames.push(tool.function.name);\n    }\n  }\n  return allTools;\n}\n\n/**\n * @deprecated use CopilotRuntime instead\n */\nexport class CopilotBackend extends CopilotRuntime {}\n","import { Message, ToolDefinition, ChatCompletionChunk, encodeResult } from \"@copilotkit/shared\";\n\nexport function writeChatCompletionChunk(\n  controller: ReadableStreamDefaultController<any>,\n  chunk: ChatCompletionChunk,\n) {\n  const payload = new TextEncoder().encode(\"data: \" + JSON.stringify(chunk) + \"\\n\\n\");\n  controller!.enqueue(payload);\n}\n\nexport function writeChatCompletionContent(\n  controller: ReadableStreamDefaultController<any>,\n  content: string = \"\",\n  toolCalls?: any,\n) {\n  const chunk: ChatCompletionChunk = {\n    choices: [\n      {\n        delta: {\n          role: \"assistant\",\n          content: content,\n          ...(toolCalls ? { tool_calls: toolCalls } : {}),\n        },\n      },\n    ],\n  };\n\n  writeChatCompletionChunk(controller, chunk);\n}\n\nexport function writeChatCompletionResult(\n  controller: ReadableStreamDefaultController<any>,\n  functionName: string,\n  result: any,\n) {\n  let resultString = encodeResult(result);\n\n  const chunk: ChatCompletionChunk = {\n    choices: [\n      {\n        delta: {\n          role: \"function\",\n          content: resultString,\n          name: functionName,\n        },\n      },\n    ],\n  };\n\n  writeChatCompletionChunk(controller, chunk);\n}\n\nexport function writeChatCompletionEnd(controller: ReadableStreamDefaultController<any>) {\n  const payload = new TextEncoder().encode(\"data: [DONE]\\n\\n\");\n  controller.enqueue(payload);\n}\n\nexport function limitOpenAIMessagesToTokenCount(\n  messages: Message[],\n  tools: ToolDefinition[],\n  maxTokens: number,\n): Message[] {\n  const result: Message[] = [];\n  const toolsNumTokens = countToolsTokens(tools);\n  if (toolsNumTokens > maxTokens) {\n    throw new Error(`Too many tokens in function definitions: ${toolsNumTokens} > ${maxTokens}`);\n  }\n  maxTokens -= toolsNumTokens;\n\n  for (const message of messages) {\n    if (message.role === \"system\") {\n      const numTokens = countMessageTokens(message);\n      maxTokens -= numTokens;\n\n      if (maxTokens < 0) {\n        throw new Error(\"Not enough tokens for system message.\");\n      }\n    }\n  }\n\n  let cutoff: boolean = false;\n\n  const reversedMessages = [...messages].reverse();\n  for (const message of reversedMessages) {\n    if (message.role === \"system\") {\n      result.unshift(message);\n      continue;\n    } else if (cutoff) {\n      continue;\n    }\n    let numTokens = countMessageTokens(message);\n    if (maxTokens < numTokens) {\n      cutoff = true;\n      continue;\n    }\n    result.unshift(message);\n    maxTokens -= numTokens;\n  }\n\n  return result;\n}\n\nexport function maxTokensForOpenAIModel(model: string): number {\n  return maxTokensByModel[model] || DEFAULT_MAX_TOKENS;\n}\n\nconst DEFAULT_MAX_TOKENS = 8192;\n\nconst maxTokensByModel: { [key: string]: number } = {\n  // GPT-4\n  \"gpt-4-0125-preview\": 128000,\n  \"gpt-4-turbo-preview\": 128000,\n  \"gpt-4-1106-preview\": 128000,\n  \"gpt-4-vision-preview\": 128000,\n  \"gpt-4-1106-vision-preview\": 128000,\n  \"gpt-4-32k\": 32768,\n  \"gpt-4-32k-0613\": 32768,\n  \"gpt-4-32k-0314\": 32768,\n  \"gpt-4\": 8192,\n  \"gpt-4-0613\": 8192,\n  \"gpt-4-0314\": 8192,\n\n  // GPT-3.5\n  \"gpt-3.5-turbo-0125\": 16385,\n  \"gpt-3.5-turbo\": 16385,\n  \"gpt-3.5-turbo-1106\": 16385,\n  \"gpt-3.5-turbo-instruct\": 4096,\n  \"gpt-3.5-turbo-16k\": 16385,\n  \"gpt-3.5-turbo-0613\": 4096,\n  \"gpt-3.5-turbo-16k-0613\": 16385,\n  \"gpt-3.5-turbo-0301\": 4097,\n};\n\nfunction countToolsTokens(functions: ToolDefinition[]): number {\n  if (functions.length === 0) {\n    return 0;\n  }\n  const json = JSON.stringify(functions);\n  return countTokens(json);\n}\n\nfunction countMessageTokens(message: Message): number {\n  if (message.content) {\n    return countTokens(message.content);\n  } else if (message.function_call) {\n    return countTokens(JSON.stringify(message.function_call));\n  }\n  return 0;\n}\n\nfunction countTokens(text: string): number {\n  return text.length / 3;\n}\n","import {\n  Action,\n  parseChatCompletion,\n  ToolCallPayload,\n  ChatCompletionChunk,\n} from \"@copilotkit/shared\";\nimport {\n  writeChatCompletionChunk,\n  writeChatCompletionContent,\n  writeChatCompletionEnd,\n  writeChatCompletionResult,\n} from \"./openai\";\n\n/**\n * Execute a function call and write the result to the stream.\n * TODO: should this return a stream to get process other function calls?\n */\nasync function executeFunctionCall(\n  controller: ReadableStreamDefaultController<any>,\n  action: Action<any>,\n  functionCallArguments: string,\n): Promise<void> {\n  // Prepare arguments for function calling\n  let args: Record<string, any>[] = [];\n  if (functionCallArguments) {\n    args = JSON.parse(functionCallArguments);\n  }\n\n  // call the function\n  const result = await action.handler(args);\n\n  // We support several types of return values from functions:\n\n  // 1. string\n  // Just send the result as the content of the chunk.\n  if (result && typeof result === \"string\") {\n    writeChatCompletionResult(controller, action.name, result);\n  }\n\n  // 2. AIMessage\n  // Send the content and function call of the AIMessage as the content of the chunk.\n  else if (result && \"content\" in result && typeof result.content === \"string\") {\n    writeChatCompletionContent(controller, result.content, result.additional_kwargs?.tool_calls);\n  }\n\n  // 3. BaseMessageChunk\n  // Send the content and function call of the AIMessage as the content of the chunk.\n  else if (result && \"lc_kwargs\" in result) {\n    writeChatCompletionContent(controller, result.lc_kwargs?.content, result.lc_kwargs?.tool_calls);\n  }\n\n  // 4. IterableReadableStream\n  // Stream the result of the LangChain function.\n  else if (result && \"getReader\" in result) {\n    let reader = result.getReader();\n    while (true) {\n      try {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        writeChatCompletionContent(\n          controller,\n          value?.lc_kwargs?.content,\n          value.lc_kwargs?.additional_kwargs?.tool_calls,\n        );\n      } catch (error) {\n        console.error(\"Error reading from stream\", error);\n        break;\n      }\n    }\n  }\n\n  // 5. Any other type, return JSON result\n  else {\n    writeChatCompletionResult(controller, action.name, result);\n  }\n}\n\n/**\n * This function intercepts the stream from the chat completion and processes it according to the defined actions.\n * It decodes the stream, executes any server-side functions as specified in the actions, and forwards the rest to the client.\n *\n * @param stream - The incoming ReadableStream of Uint8Array from the chat completion.\n * @param actions - An array of Action objects that define server-side functions to be executed.\n * @param debug - A boolean flag to enable debug logging.\n * @returns A new ReadableStream that is the result of processing the incoming stream.\n */\nexport function copilotkitStreamInterceptor(\n  stream: ReadableStream<Uint8Array>,\n  actions: Action<any>[],\n  debug: boolean = false,\n): ReadableStream {\n  const functionsByName = actions.reduce(\n    (acc, fn) => {\n      acc[fn.name] = fn;\n      return acc;\n    },\n    {} as Record<string, Action<any>>,\n  );\n\n  const decodedStream = parseChatCompletion(stream);\n  const reader = decodedStream.getReader();\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  // Keep track of current state as we process the stream\n\n  // Loop Invariant:\n  // Either we are in the middle of a function call that should be executed on the backend = TRUE\n  // or we are in the middle of processing a chunk that should be forwarded to the client = FALSE\n  let executeThisFunctionCall = false;\n\n  let functionCallName = \"\";\n  let functionCallArguments = \"\";\n\n  let currentFnIndex: number | null = null;\n\n  const flushFunctionCall = async (\n    controller: ReadableStreamDefaultController<any>,\n  ): Promise<void> => {\n    const action = functionsByName[functionCallName];\n    await executeFunctionCall(controller, action, functionCallArguments);\n\n    executeThisFunctionCall = false;\n    functionCallName = \"\";\n    functionCallArguments = \"\";\n  };\n\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            if (debug) {\n              console.log(\"data: [DONE]\\n\\n\");\n            }\n            if (executeThisFunctionCall) {\n              // We are at the end of the stream and still have a function call to execute\n              await flushFunctionCall(controller);\n            }\n            writeChatCompletionEnd(controller);\n            await cleanup(controller);\n            return;\n          } // done == true (terminal case)\n\n          if (debug) {\n            console.log(\"data: \" + JSON.stringify(value) + \"\\n\\n\");\n          }\n\n          type Mode = { type: \"function\"; toolCall: ToolCallPayload } | { type: \"message\" };\n\n          let mode: Mode;\n          const maybeToolCall = value.choices[0].delta.tool_calls?.[0];\n          if (maybeToolCall) {\n            mode = { type: \"function\", toolCall: maybeToolCall };\n          } else {\n            mode = { type: \"message\" };\n          }\n\n          const nextChunkIndex = mode.type === \"function\" ? mode.toolCall.index : null;\n          // If We are in the middle of a function call and got a non function call chunk\n          // or a different function call\n          // => execute the function call first\n          if (\n            executeThisFunctionCall &&\n            (mode.type != \"function\" || nextChunkIndex != currentFnIndex)\n          ) {\n            await flushFunctionCall(controller);\n          }\n          currentFnIndex = nextChunkIndex;\n\n          // if we get a message, emit the content and continue;\n          if (mode.type === \"message\") {\n            if (value.choices[0].delta.content) {\n              writeChatCompletionChunk(controller, value);\n            }\n            continue;\n          }\n\n          // if we get a function call, emit it only if we don't execute it server side\n          else if (mode.type === \"function\") {\n            // Set the function name if present\n            const maybeFunctionName = mode.toolCall.function.name;\n            if (maybeFunctionName) {\n              functionCallName = maybeFunctionName;\n            }\n            // If we have argument streamed back, add them to the function call arguments\n            const maybeArguments = mode.toolCall.function.arguments;\n            if (mode.toolCall.function.arguments) {\n              functionCallArguments += maybeArguments;\n            }\n            if (!executeThisFunctionCall) {\n              // Decide if we should execute the function call server side\n              if (functionCallName in functionsByName) {\n                executeThisFunctionCall = true;\n              }\n            }\n            mode.toolCall.function.scope = executeThisFunctionCall ? \"server\" : \"client\";\n            writeChatCompletionChunk(controller, value);\n            continue;\n          }\n        } catch (error) {\n          controller.error(error);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n\n/**\n * A ReadableStream that only emits a single chunk.\n */\nexport class SingleChunkReadableStream extends ReadableStream<any> {\n  constructor(content: string = \"\", toolCalls?: any) {\n    super({\n      start(controller) {\n        const chunk: ChatCompletionChunk = {\n          choices: [\n            {\n              delta: {\n                role: \"assistant\",\n                content,\n                ...(toolCalls ? { tool_calls: toolCalls } : {}),\n              },\n            },\n          ],\n        };\n        writeChatCompletionChunk(controller, chunk);\n        writeChatCompletionEnd(controller);\n\n        controller.close();\n      },\n      cancel() {},\n    });\n  }\n}\n","import { Action } from \"@copilotkit/shared\";\nimport { RemoteChain } from \"../types\";\nimport { RemoteRunnable } from \"langchain/runnables/remote\";\n\nexport async function remoteChainToAction(chain: RemoteChain): Promise<Action<any>> {\n  chain = { ...chain };\n  const runnable = new RemoteRunnable({ url: chain.chainUrl });\n\n  if (!chain.parameters) {\n    chain = await inferLangServeParameters(chain);\n  }\n\n  chain.parameterType ||= \"multi\";\n\n  return {\n    name: chain.name,\n    description: chain.description,\n    parameters: chain.parameters!,\n    handler: async (args: any) => {\n      let input: any;\n      if (chain.parameterType === \"single\") {\n        input = args[Object.keys(args)[0]];\n      } else {\n        input = args;\n      }\n      return await runnable.invoke(input);\n    },\n  };\n}\n\nexport async function inferLangServeParameters(chain: RemoteChain): Promise<RemoteChain> {\n  chain = { ...chain };\n\n  const supportedTypes = [\"string\", \"number\", \"boolean\"];\n\n  let schemaUrl = chain.chainUrl.replace(/\\/+$/, \"\") + \"/input_schema\";\n  let schema = await fetch(schemaUrl)\n    .then((res) => res.json())\n    .catch(() => {\n      throw new Error(\"Failed to fetch langserve schema at \" + schemaUrl);\n    });\n  // for now, don't use json schema, just do a simple conversion\n\n  if (supportedTypes.includes(schema.type)) {\n    chain.parameterType = \"single\";\n    chain.parameters = [\n      {\n        name: \"input\",\n        type: schema.type,\n        description: \"The input to the chain\",\n      },\n    ];\n  } else if (schema.type === \"object\") {\n    chain.parameterType = \"multi\";\n    chain.parameters = Object.keys(schema.properties).map((key) => {\n      let property = schema.properties[key];\n      if (!supportedTypes.includes(property.type)) {\n        throw new Error(\"Unsupported schema type\");\n      }\n      return {\n        name: key,\n        type: property.type,\n        description: property.description || \"\",\n        required: schema.required?.includes(key) || false,\n      };\n    });\n  } else {\n    throw new Error(\"Unsupported schema type\");\n  }\n\n  return chain;\n}\n","import {\n  COPILOT_CLOUD_API_URL,\n  COPILOT_CLOUD_VERSION,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  CopilotCloudConfig,\n  Message,\n} from \"@copilotkit/shared\";\n\nexport interface CloudCheckGuardrailsInputParams {\n  cloud: CopilotCloudConfig;\n  publicApiKey: string;\n  messages: Message[];\n}\n\nexport interface CloudCheckGuardrailsInputResponse {\n  status: \"allowed\" | \"denied\";\n  reason: string;\n}\n\nexport abstract class CopilotCloud {\n  abstract checkGuardrailsInput(\n    params: CloudCheckGuardrailsInputParams,\n  ): Promise<CloudCheckGuardrailsInputResponse>;\n}\n\nexport class RemoteCopilotCloud extends CopilotCloud {\n  constructor(private readonly cloudApiUrl: string = COPILOT_CLOUD_API_URL) {\n    super();\n  }\n\n  async checkGuardrailsInput({\n    cloud,\n    publicApiKey,\n    messages,\n  }: CloudCheckGuardrailsInputParams): Promise<CloudCheckGuardrailsInputResponse> {\n    const url = `${this.cloudApiUrl}/${COPILOT_CLOUD_VERSION}/copilotkit/guardrails/input`;\n\n    const response = await fetch(url, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey,\n      },\n      body: JSON.stringify({ messages, cloud }),\n    });\n\n    if (!response.ok) {\n      let message = response.statusText;\n\n      // try to parse the response body for a more detailed error message\n      try {\n        const json = await response.json();\n        if (json.message) {\n          message = json.message;\n        }\n      } catch (error) {}\n\n      throw new Error(\"Failed to check input guardrails: \" + message);\n    }\n    const json = await response.json();\n    return { status: json.status, reason: json.reason };\n  }\n}\n","import OpenAI from \"openai\";\nimport { CopilotKitResponse, CopilotKitServiceAdapter } from \"../types/service-adapter\";\nimport { limitOpenAIMessagesToTokenCount, maxTokensForOpenAIModel } from \"../utils/openai\";\n\nconst DEFAULT_MODEL = \"gpt-4-1106-preview\";\n\nexport interface OpenAIAdapterParams {\n  openai?: OpenAI;\n  model?: string;\n}\n\nexport class OpenAIAdapter implements CopilotKitServiceAdapter {\n  private model: string = DEFAULT_MODEL;\n\n  private _openai: OpenAI;\n  public get openai(): OpenAI {\n    return this._openai;\n  }\n\n  constructor(params?: OpenAIAdapterParams) {\n    this._openai = params?.openai || new OpenAI({});\n    if (params?.model) {\n      this.model = params.model;\n    }\n  }\n\n  async getResponse(forwardedProps: any): Promise<CopilotKitResponse> {\n    // copy forwardedProps to avoid modifying the original object\n    forwardedProps = { ...forwardedProps };\n\n    // Remove tools if there are none to avoid OpenAI API errors\n    // when sending an empty array of tools\n    if (forwardedProps.tools && forwardedProps.tools.length === 0) {\n      delete forwardedProps.tools;\n    }\n\n    const messages = limitOpenAIMessagesToTokenCount(\n      forwardedProps.messages || [],\n      forwardedProps.tools || [],\n      maxTokensForOpenAIModel(forwardedProps.model || this.model),\n    );\n\n    return new Promise((resolve, reject) => {\n      // remove message.function_call.scope if it's present.\n      // scope is a field we inject as a temporary workaround (see elsewhere), which openai doesn't understand\n      messages.forEach((message) => {\n        if (message.function_call?.scope) {\n          delete message.function_call.scope;\n        }\n      });\n\n      const stream = this.openai.beta.chat.completions.stream({\n        model: this.model,\n        ...forwardedProps,\n        stream: true,\n        messages: messages as any,\n      });\n      stream.on(\"error\", (error) => {\n        reject(error); // Reject the promise with the error\n      });\n      stream.on(\"connect\", () => {\n        resolve({ stream: stream.toReadableStream() });\n      });\n    });\n  }\n}\n","import { ChatCompletionChunk } from \"@copilotkit/shared\";\nimport {\n  AIMessage,\n  BaseMessage,\n  BaseMessageChunk,\n  FunctionMessage,\n  HumanMessage,\n  SystemMessage,\n  ToolMessage,\n} from \"@langchain/core/messages\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport { CopilotKitServiceAdapter } from \"../types\";\nimport { writeChatCompletionChunk, writeChatCompletionEnd } from \"../utils\";\nimport { CopilotKitResponse } from \"../types/service-adapter\";\nimport { SingleChunkReadableStream } from \"../utils\";\n\nexport type LangChainMessageStream = IterableReadableStream<BaseMessageChunk>;\nexport type LangChainReturnType = LangChainMessageStream | BaseMessageChunk | string | AIMessage;\n\nexport class LangChainAdapter implements CopilotKitServiceAdapter {\n  constructor(private chainFn: (forwardedProps: any) => Promise<LangChainReturnType>) {}\n\n  async getResponse(forwardedProps: any): Promise<CopilotKitResponse> {\n    forwardedProps = this.transformProps(forwardedProps);\n\n    const result = await this.chainFn(forwardedProps);\n\n    // We support several types of return values from LangChain functions:\n\n    // 1. string\n    // Just send one chunk with the string as the content.\n    if (typeof result === \"string\") {\n      return {\n        stream: new SingleChunkReadableStream(result),\n      };\n    }\n\n    // 2. AIMessage\n    // Send the content and function call of the AIMessage as the content of the chunk.\n    else if (\"content\" in result && typeof result.content === \"string\") {\n      return {\n        stream: new SingleChunkReadableStream(result.content, result.additional_kwargs?.tool_calls),\n      };\n    }\n\n    // 3. BaseMessageChunk\n    // Send the content and function call of the AIMessage as the content of the chunk.\n    else if (\"lc_kwargs\" in result) {\n      return {\n        stream: new SingleChunkReadableStream(\n          result.lc_kwargs?.content,\n          result.lc_kwargs?.tool_calls,\n        ),\n      };\n    }\n\n    // 4. IterableReadableStream\n    // Stream the result of the LangChain function.\n    else if (\"getReader\" in result) {\n      return {\n        stream: this.streamResult(result),\n      };\n    }\n\n    // TODO write function call result!\n\n    console.error(\"Invalid return type from LangChain function.\");\n    throw new Error(\"Invalid return type from LangChain function.\");\n  }\n\n  /**\n   * Transforms the props that are forwarded to the LangChain function.\n   * Currently this just transforms the messages to the format that LangChain expects.\n   *\n   * @param forwardedProps\n   * @returns {any}\n   */\n  private transformProps(forwardedProps: any) {\n    const forwardedPropsCopy = Object.assign({}, forwardedProps);\n\n    // map messages to langchain format\n    if (forwardedProps.messages && Array.isArray(forwardedProps.messages)) {\n      const newMessages: BaseMessage[] = [];\n\n      for (const message of forwardedProps.messages) {\n        if (message.role === \"user\") {\n          newMessages.push(new HumanMessage(message.content));\n        } else if (message.role === \"assistant\") {\n          if (message.function_call) {\n            newMessages.push(\n              new AIMessage({\n                content: \"\",\n                tool_calls: [\n                  {\n                    id: message.function_call.name + \"-\" + forwardedProps.messages.indexOf(message),\n                    args: JSON.parse(message.function_call.arguments),\n                    name: message.function_call.name,\n                  },\n                ],\n              }),\n            );\n          } else {\n            newMessages.push(new AIMessage(message.content));\n          }\n        } else if (message.role === \"system\") {\n          newMessages.push(new SystemMessage(message.content));\n        } else if (message.role == \"function\") {\n          // An assistant message with 'tool_calls' must be followed by tool messages responding to each 'tool_call_id'\n          newMessages.push(\n            new ToolMessage({\n              content: message.content,\n              tool_call_id: message.name + \"-\" + (forwardedProps.messages.indexOf(message) - 1),\n            }),\n          );\n        }\n      }\n      forwardedPropsCopy.messages = newMessages;\n    }\n\n    return forwardedPropsCopy;\n  }\n\n  /**\n   * Reads from the LangChainMessageStream and converts the output to a ReadableStream.\n   *\n   * @param streamedChain\n   * @returns ReadableStream\n   */\n  streamResult(streamedChain: LangChainMessageStream): ReadableStream<any> {\n    let reader = streamedChain.getReader();\n\n    async function cleanup(controller?: ReadableStreamDefaultController<BaseMessageChunk>) {\n      if (controller) {\n        try {\n          controller.close();\n        } catch (_) {}\n      }\n      if (reader) {\n        try {\n          await reader.cancel();\n        } catch (_) {}\n      }\n    }\n\n    return new ReadableStream<any>({\n      async pull(controller) {\n        while (true) {\n          try {\n            const { done, value } = await reader.read();\n\n            if (done) {\n              writeChatCompletionEnd(controller);\n              await cleanup(controller);\n              return;\n            }\n\n            const toolCalls = value.lc_kwargs?.additional_kwargs?.tool_calls;\n            const content = value?.lc_kwargs?.content;\n            const chunk: ChatCompletionChunk = {\n              choices: [\n                {\n                  delta: {\n                    role: \"assistant\",\n                    content: content,\n                    ...(toolCalls ? { tool_calls: toolCalls } : {}),\n                  },\n                },\n              ],\n            };\n            writeChatCompletionChunk(controller, chunk);\n          } catch (error) {\n            controller.error(error);\n            await cleanup(controller);\n            return;\n          }\n        }\n      },\n      cancel() {\n        cleanup();\n      },\n    });\n  }\n}\n","import OpenAI from \"openai\";\nimport { CopilotKitServiceAdapter, CopilotKitResponse } from \"../types/service-adapter\";\nimport { writeChatCompletionChunk, writeChatCompletionEnd } from \"../utils/openai\";\nimport { ChatCompletionChunk, Message } from \"@copilotkit/shared\";\n\nconst RUN_STATUS_POLL_INTERVAL = 100;\n\nexport interface OpenAIAssistantAdapterParams {\n  assistantId: string;\n  openai?: OpenAI;\n  codeInterpreterEnabled?: boolean;\n  retrievalEnabled?: boolean;\n}\n\nexport class OpenAIAssistantAdapter implements CopilotKitServiceAdapter {\n  private openai: OpenAI;\n  private codeInterpreterEnabled: boolean;\n  private assistantId: string;\n  private retrievalEnabled: boolean;\n\n  constructor(params: OpenAIAssistantAdapterParams) {\n    this.openai = params.openai || new OpenAI({});\n    this.codeInterpreterEnabled = params.codeInterpreterEnabled === false || true;\n    this.retrievalEnabled = params.retrievalEnabled === false || true;\n    this.assistantId = params.assistantId;\n  }\n\n  async waitForRun(run: OpenAI.Beta.Threads.Runs.Run): Promise<OpenAI.Beta.Threads.Runs.Run> {\n    while (true) {\n      const status = await this.openai.beta.threads.runs.retrieve(run.thread_id, run.id);\n      if (status.status === \"completed\" || status.status === \"requires_action\") {\n        return status;\n      } else if (status.status !== \"in_progress\" && status.status !== \"queued\") {\n        console.error(`Thread run failed with status: ${status.status}`);\n        throw new Error(`Thread run failed with status: ${status.status}`);\n      }\n      await new Promise((resolve) => setTimeout(resolve, RUN_STATUS_POLL_INTERVAL));\n    }\n  }\n\n  async submitToolOutputs(threadId: string, runId: string, forwardMessages: Message[]) {\n    let run = await this.openai.beta.threads.runs.retrieve(threadId, runId);\n\n    if (!run.required_action) {\n      throw new Error(\"No tool outputs required\");\n    }\n\n    const functionResults: Message[] = [];\n    // get all function results at the tail of the messages\n    let i = forwardMessages.length - 1;\n    for (; i >= 0; i--) {\n      if (forwardMessages[i].role === \"function\") {\n        functionResults.unshift(forwardMessages[i]);\n      } else {\n        break;\n      }\n    }\n\n    const toolCallsIds = run.required_action.submit_tool_outputs.tool_calls.map(\n      (toolCall) => toolCall.id,\n    );\n\n    if (toolCallsIds.length != functionResults.length) {\n      throw new Error(\"Number of function results does not match the number of tool calls\");\n    }\n\n    const toolOutputs: any[] = [];\n\n    // match tool ids with function results\n    for (let i = 0; i < functionResults.length; i++) {\n      const toolCallId = toolCallsIds[i];\n      const functionResult = functionResults[i];\n      toolOutputs.push({\n        tool_call_id: toolCallId,\n        output: functionResult.content || \"\",\n      });\n    }\n\n    run = await this.openai.beta.threads.runs.submitToolOutputs(threadId, runId, {\n      tool_outputs: toolOutputs,\n    });\n\n    return await this.waitForRun(run);\n  }\n\n  async submitUserMessage(threadId: string, forwardedProps: any) {\n    const forwardMessages = forwardedProps.messages || [];\n\n    const message = forwardMessages[forwardMessages.length - 1];\n    await this.openai.beta.threads.messages.create(threadId, {\n      role: message.role as \"user\",\n      content: message.content,\n    });\n\n    const tools = [\n      ...(forwardedProps.tools || []),\n      ...(this.codeInterpreterEnabled ? [{ type: \"code_interpreter\" }] : []),\n      ...(this.retrievalEnabled ? [{ type: \"retrieval\" }] : []),\n    ];\n\n    // build instructions by joining all system messages\n    const instructions = forwardMessages\n      .filter((message: Message) => message.role === \"system\")\n      .map((message: Message) => message.content)\n      .join(\"\\n\\n\");\n\n    // run the thread\n    let run = await this.openai.beta.threads.runs.create(threadId, {\n      assistant_id: this.assistantId,\n      instructions,\n      tools: tools,\n    });\n\n    return await this.waitForRun(run);\n  }\n\n  async getResponse(forwardedProps: any): Promise<CopilotKitResponse> {\n    // copy forwardedProps to avoid modifying the original object\n    forwardedProps = { ...forwardedProps };\n\n    const forwardMessages = forwardedProps.messages || [];\n\n    // Remove tools if there are none to avoid OpenAI API errors\n    // when sending an empty array of tools\n    if (forwardedProps.tools && forwardedProps.tools.length === 0) {\n      delete forwardedProps.tools;\n    }\n\n    // get the thread from forwardedProps or create a new one\n    const threadId: string =\n      forwardedProps.threadId || (await this.openai.beta.threads.create()).id;\n\n    let run: OpenAI.Beta.Threads.Runs.Run | null = null;\n\n    // submit function outputs\n    if (\n      forwardMessages.length > 0 &&\n      forwardMessages[forwardMessages.length - 1].role === \"function\"\n    ) {\n      run = await this.submitToolOutputs(threadId, forwardedProps.runId, forwardMessages);\n    }\n    // submit user message\n    else if (\n      forwardMessages.length > 0 &&\n      forwardMessages[forwardMessages.length - 1].role === \"user\"\n    ) {\n      run = await this.submitUserMessage(threadId, forwardedProps);\n    }\n    // unsupported message\n    else {\n      console.error(\"No actionable message found in the messages\");\n      throw new Error(\"No actionable message found in the messages\");\n    }\n\n    if (run.status === \"requires_action\") {\n      // return the tool calls\n      return {\n        stream: new AssistantSingleChunkReadableStream(\n          \"\",\n          run.required_action!.submit_tool_outputs.tool_calls,\n        ),\n        headers: { threadId, runId: run.id },\n      };\n    } else {\n      // return the last message\n      const newMessages = await this.openai.beta.threads.messages.list(threadId, {\n        limit: 1,\n        order: \"desc\",\n      });\n\n      const content = newMessages.data[0].content[0];\n      const contentString = content.type === \"text\" ? content.text.value : \"\";\n\n      return {\n        stream: new AssistantSingleChunkReadableStream(contentString),\n        headers: { threadId },\n      };\n    }\n  }\n}\n\nclass AssistantSingleChunkReadableStream extends ReadableStream<any> {\n  constructor(\n    content: string,\n    toolCalls?: OpenAI.Beta.Threads.Runs.RequiredActionFunctionToolCall[],\n  ) {\n    super({\n      start(controller) {\n        let tool_calls: any = undefined;\n        if (toolCalls) {\n          tool_calls = toolCalls.map((toolCall, index) => {\n            return {\n              index,\n              id: toolCall.id,\n              function: {\n                name: toolCall.function.name,\n                arguments: toolCall.function.arguments,\n              },\n            };\n          });\n        }\n        const chunk: ChatCompletionChunk = {\n          choices: [\n            {\n              delta: {\n                content: content,\n                role: \"assistant\",\n                tool_calls,\n              },\n            },\n          ],\n        };\n        writeChatCompletionChunk(controller, chunk);\n        writeChatCompletionEnd(controller);\n\n        controller.close();\n      },\n      cancel() {},\n    });\n  }\n}\n"],"mappings":"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","names":["import_shared","import_shared","import_shared","import_shared","json","success","import_openai","OpenAI","import_openai","OpenAI","i","message"]}