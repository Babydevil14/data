import {
  RemoteCopilotCloud
} from "./chunk-HRMU7U44.mjs";
import {
  remoteChainToAction
} from "./chunk-7ZFVFHJF.mjs";
import {
  SingleChunkReadableStream,
  copilotkitStreamInterceptor
} from "./chunk-XVRXIQLE.mjs";

// src/lib/copilotkit-runtime.ts
import {
  EXCLUDE_FROM_FORWARD_PROPS_KEYS,
  actionToChatCompletionFunction,
  annotatedFunctionToAction,
  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER
} from "@copilotkit/shared";
var CopilotRuntime = class {
  constructor(params) {
    this.actions = [];
    this.langserve = [];
    this.debug = false;
    for (const action of (params == null ? void 0 : params.actions) || []) {
      if ("argumentAnnotations" in action) {
        this.actions.push(annotatedFunctionToAction(action));
      } else {
        this.actions.push(action);
      }
    }
    for (const chain of (params == null ? void 0 : params.langserve) || []) {
      this.langserve.push(remoteChainToAction(chain));
    }
    this.debug = (params == null ? void 0 : params.debug) || false;
    this.copilotCloud = (params == null ? void 0 : params.copilotCloud) || new RemoteCopilotCloud();
  }
  addAction(action) {
    this.removeAction(action.name);
    if ("argumentAnnotations" in action) {
      this.actions.push(annotatedFunctionToAction(action));
    } else {
      this.actions.push(action);
    }
  }
  removeAction(actionName) {
    this.actions = this.actions.filter((f) => f.name !== actionName);
  }
  removeBackendOnlyProps(forwardedProps) {
    const backendOnlyPropsKeys = forwardedProps[EXCLUDE_FROM_FORWARD_PROPS_KEYS];
    if (Array.isArray(backendOnlyPropsKeys)) {
      backendOnlyPropsKeys.forEach((key) => {
        const success2 = Reflect.deleteProperty(forwardedProps, key);
        if (!success2) {
          console.error(`Failed to delete property ${key}`);
        }
      });
      const success = Reflect.deleteProperty(forwardedProps, EXCLUDE_FROM_FORWARD_PROPS_KEYS);
      if (!success) {
        console.error(`Failed to delete EXCLUDE_FROM_FORWARD_PROPS_KEYS`);
      }
    } else if (backendOnlyPropsKeys) {
      console.error("backendOnlyPropsKeys is not an array");
    }
  }
  async getResponse(forwardedProps, serviceAdapter, publicApiKey) {
    this.removeBackendOnlyProps(forwardedProps);
    const cloud = forwardedProps.cloud;
    delete forwardedProps.cloud;
    const langserveFunctions = [];
    for (const chainPromise of this.langserve) {
      try {
        const chain = await chainPromise;
        langserveFunctions.push(chain);
      } catch (error) {
        console.error("Error loading langserve chain:", error);
      }
    }
    const serversideTools = [...this.actions, ...langserveFunctions];
    const mergedTools = flattenToolCallsNoDuplicates([
      ...serversideTools.map(actionToChatCompletionFunction),
      ...forwardedProps.tools || []
    ]);
    try {
      const result = await serviceAdapter.getResponse({
        ...forwardedProps,
        tools: mergedTools
      });
      if (publicApiKey !== void 0) {
        try {
          const checkGuardrailsInputResult = await this.copilotCloud.checkGuardrailsInput({
            cloud,
            publicApiKey,
            messages: forwardedProps.messages || []
          });
          if (checkGuardrailsInputResult.status === "denied") {
            return {
              stream: new SingleChunkReadableStream(checkGuardrailsInputResult.reason),
              headers: result.headers
            };
          }
        } catch (error) {
          console.error("Error checking guardrails:", error);
        }
      }
      const stream = copilotkitStreamInterceptor(result.stream, serversideTools, this.debug);
      return { stream, headers: result.headers };
    } catch (error) {
      console.error("Error getting response:", error);
      throw error;
    }
  }
  async response(req, serviceAdapter) {
    const publicApiKey = req.headers.get(COPILOT_CLOUD_PUBLIC_API_KEY_HEADER) || void 0;
    try {
      const forwardedProps = await req.json();
      const response = await this.getResponse(forwardedProps, serviceAdapter, publicApiKey);
      return new Response(response.stream, { headers: response.headers });
    } catch (error) {
      return new Response(error, { status: error.status });
    }
  }
  async streamHttpServerResponse(req, res, serviceAdapter, headers) {
    const bodyParser = new Promise((resolve, reject) => {
      if ("body" in req) {
        resolve(req.body);
        return;
      }
      let body = "";
      req.on("data", (chunk) => body += chunk.toString());
      req.on("end", () => {
        try {
          resolve(JSON.parse(body));
        } catch (error) {
          reject(error);
        }
      });
    });
    const forwardedProps = await bodyParser;
    const publicApiKey = (req.header ? (
      // use header() in express
      req.header(COPILOT_CLOUD_PUBLIC_API_KEY_HEADER)
    ) : (
      // use headers in node http
      req.headers[COPILOT_CLOUD_PUBLIC_API_KEY_HEADER.toLowerCase()]
    )) || void 0;
    const response = await this.getResponse(forwardedProps, serviceAdapter, publicApiKey);
    const mergedHeaders = { ...headers, ...response.headers };
    res.writeHead(200, mergedHeaders);
    const stream = response.stream;
    const reader = stream.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        res.end();
        break;
      } else {
        res.write(new TextDecoder().decode(value));
      }
    }
  }
};
function flattenToolCallsNoDuplicates(toolsByPriority) {
  let allTools = [];
  const allToolNames = [];
  for (const tool of toolsByPriority) {
    if (!allToolNames.includes(tool.function.name)) {
      allTools.push(tool);
      allToolNames.push(tool.function.name);
    }
  }
  return allTools;
}
var CopilotBackend = class extends CopilotRuntime {
};

export {
  CopilotRuntime,
  flattenToolCallsNoDuplicates,
  CopilotBackend
};
//# sourceMappingURL=chunk-RBQBYYIC.mjs.map