{"version":3,"sources":["../src/lib/openai-adapter.ts"],"sourcesContent":["import OpenAI from \"openai\";\nimport { CopilotKitResponse, CopilotKitServiceAdapter } from \"../types/service-adapter\";\nimport { limitOpenAIMessagesToTokenCount, maxTokensForOpenAIModel } from \"../utils/openai\";\n\nconst DEFAULT_MODEL = \"gpt-4-1106-preview\";\n\nexport interface OpenAIAdapterParams {\n  openai?: OpenAI;\n  model?: string;\n}\n\nexport class OpenAIAdapter implements CopilotKitServiceAdapter {\n  private model: string = DEFAULT_MODEL;\n\n  private _openai: OpenAI;\n  public get openai(): OpenAI {\n    return this._openai;\n  }\n\n  constructor(params?: OpenAIAdapterParams) {\n    this._openai = params?.openai || new OpenAI({});\n    if (params?.model) {\n      this.model = params.model;\n    }\n  }\n\n  async getResponse(forwardedProps: any): Promise<CopilotKitResponse> {\n    // copy forwardedProps to avoid modifying the original object\n    forwardedProps = { ...forwardedProps };\n\n    // Remove tools if there are none to avoid OpenAI API errors\n    // when sending an empty array of tools\n    if (forwardedProps.tools && forwardedProps.tools.length === 0) {\n      delete forwardedProps.tools;\n    }\n\n    const messages = limitOpenAIMessagesToTokenCount(\n      forwardedProps.messages || [],\n      forwardedProps.tools || [],\n      maxTokensForOpenAIModel(forwardedProps.model || this.model),\n    );\n\n    return new Promise((resolve, reject) => {\n      // remove message.function_call.scope if it's present.\n      // scope is a field we inject as a temporary workaround (see elsewhere), which openai doesn't understand\n      messages.forEach((message) => {\n        if (message.function_call?.scope) {\n          delete message.function_call.scope;\n        }\n      });\n\n      const stream = this.openai.beta.chat.completions.stream({\n        model: this.model,\n        ...forwardedProps,\n        stream: true,\n        messages: messages as any,\n      });\n      stream.on(\"error\", (error) => {\n        reject(error); // Reject the promise with the error\n      });\n      stream.on(\"connect\", () => {\n        resolve({ stream: stream.toReadableStream() });\n      });\n    });\n  }\n}\n"],"mappings":";;;;;;AAAA,OAAO,YAAY;AAInB,IAAM,gBAAgB;AAOf,IAAM,gBAAN,MAAwD;AAAA,EAQ7D,YAAY,QAA8B;AAP1C,SAAQ,QAAgB;AAQtB,SAAK,WAAU,iCAAQ,WAAU,IAAI,OAAO,CAAC,CAAC;AAC9C,QAAI,iCAAQ,OAAO;AACjB,WAAK,QAAQ,OAAO;AAAA,IACtB;AAAA,EACF;AAAA,EATA,IAAW,SAAiB;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA,EASA,MAAM,YAAY,gBAAkD;AAElE,qBAAiB,EAAE,GAAG,eAAe;AAIrC,QAAI,eAAe,SAAS,eAAe,MAAM,WAAW,GAAG;AAC7D,aAAO,eAAe;AAAA,IACxB;AAEA,UAAM,WAAW;AAAA,MACf,eAAe,YAAY,CAAC;AAAA,MAC5B,eAAe,SAAS,CAAC;AAAA,MACzB,wBAAwB,eAAe,SAAS,KAAK,KAAK;AAAA,IAC5D;AAEA,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AAGtC,eAAS,QAAQ,CAAC,YAAY;AA7CpC;AA8CQ,aAAI,aAAQ,kBAAR,mBAAuB,OAAO;AAChC,iBAAO,QAAQ,cAAc;AAAA,QAC/B;AAAA,MACF,CAAC;AAED,YAAM,SAAS,KAAK,OAAO,KAAK,KAAK,YAAY,OAAO;AAAA,QACtD,OAAO,KAAK;AAAA,QACZ,GAAG;AAAA,QACH,QAAQ;AAAA,QACR;AAAA,MACF,CAAC;AACD,aAAO,GAAG,SAAS,CAAC,UAAU;AAC5B,eAAO,KAAK;AAAA,MACd,CAAC;AACD,aAAO,GAAG,WAAW,MAAM;AACzB,gBAAQ,EAAE,QAAQ,OAAO,iBAAiB,EAAE,CAAC;AAAA,MAC/C,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;","names":[]}