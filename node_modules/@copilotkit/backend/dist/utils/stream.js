"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/stream.ts
var stream_exports = {};
__export(stream_exports, {
  SingleChunkReadableStream: () => SingleChunkReadableStream,
  copilotkitStreamInterceptor: () => copilotkitStreamInterceptor
});
module.exports = __toCommonJS(stream_exports);
var import_shared2 = require("@copilotkit/shared");

// src/utils/openai.ts
var import_shared = require("@copilotkit/shared");
function writeChatCompletionChunk(controller, chunk) {
  const payload = new TextEncoder().encode("data: " + JSON.stringify(chunk) + "\n\n");
  controller.enqueue(payload);
}
function writeChatCompletionContent(controller, content = "", toolCalls) {
  const chunk = {
    choices: [
      {
        delta: {
          role: "assistant",
          content,
          ...toolCalls ? { tool_calls: toolCalls } : {}
        }
      }
    ]
  };
  writeChatCompletionChunk(controller, chunk);
}
function writeChatCompletionResult(controller, functionName, result) {
  let resultString = (0, import_shared.encodeResult)(result);
  const chunk = {
    choices: [
      {
        delta: {
          role: "function",
          content: resultString,
          name: functionName
        }
      }
    ]
  };
  writeChatCompletionChunk(controller, chunk);
}
function writeChatCompletionEnd(controller) {
  const payload = new TextEncoder().encode("data: [DONE]\n\n");
  controller.enqueue(payload);
}

// src/utils/stream.ts
async function executeFunctionCall(controller, action, functionCallArguments) {
  var _a, _b, _c, _d, _e, _f;
  let args = [];
  if (functionCallArguments) {
    args = JSON.parse(functionCallArguments);
  }
  const result = await action.handler(args);
  if (result && typeof result === "string") {
    writeChatCompletionResult(controller, action.name, result);
  } else if (result && "content" in result && typeof result.content === "string") {
    writeChatCompletionContent(controller, result.content, (_a = result.additional_kwargs) == null ? void 0 : _a.tool_calls);
  } else if (result && "lc_kwargs" in result) {
    writeChatCompletionContent(controller, (_b = result.lc_kwargs) == null ? void 0 : _b.content, (_c = result.lc_kwargs) == null ? void 0 : _c.tool_calls);
  } else if (result && "getReader" in result) {
    let reader = result.getReader();
    while (true) {
      try {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        writeChatCompletionContent(
          controller,
          (_d = value == null ? void 0 : value.lc_kwargs) == null ? void 0 : _d.content,
          (_f = (_e = value.lc_kwargs) == null ? void 0 : _e.additional_kwargs) == null ? void 0 : _f.tool_calls
        );
      } catch (error) {
        console.error("Error reading from stream", error);
        break;
      }
    }
  } else {
    writeChatCompletionResult(controller, action.name, result);
  }
}
function copilotkitStreamInterceptor(stream, actions, debug = false) {
  const functionsByName = actions.reduce(
    (acc, fn) => {
      acc[fn.name] = fn;
      return acc;
    },
    {}
  );
  const decodedStream = (0, import_shared2.parseChatCompletion)(stream);
  const reader = decodedStream.getReader();
  async function cleanup(controller) {
    if (controller) {
      try {
        controller.close();
      } catch (_) {
      }
    }
    if (reader) {
      try {
        await reader.cancel();
      } catch (_) {
      }
    }
  }
  let executeThisFunctionCall = false;
  let functionCallName = "";
  let functionCallArguments = "";
  let currentFnIndex = null;
  const flushFunctionCall = async (controller) => {
    const action = functionsByName[functionCallName];
    await executeFunctionCall(controller, action, functionCallArguments);
    executeThisFunctionCall = false;
    functionCallName = "";
    functionCallArguments = "";
  };
  return new ReadableStream({
    async pull(controller) {
      var _a;
      while (true) {
        try {
          const { done, value } = await reader.read();
          if (done) {
            if (debug) {
              console.log("data: [DONE]\n\n");
            }
            if (executeThisFunctionCall) {
              await flushFunctionCall(controller);
            }
            writeChatCompletionEnd(controller);
            await cleanup(controller);
            return;
          }
          if (debug) {
            console.log("data: " + JSON.stringify(value) + "\n\n");
          }
          let mode;
          const maybeToolCall = (_a = value.choices[0].delta.tool_calls) == null ? void 0 : _a[0];
          if (maybeToolCall) {
            mode = { type: "function", toolCall: maybeToolCall };
          } else {
            mode = { type: "message" };
          }
          const nextChunkIndex = mode.type === "function" ? mode.toolCall.index : null;
          if (executeThisFunctionCall && (mode.type != "function" || nextChunkIndex != currentFnIndex)) {
            await flushFunctionCall(controller);
          }
          currentFnIndex = nextChunkIndex;
          if (mode.type === "message") {
            if (value.choices[0].delta.content) {
              writeChatCompletionChunk(controller, value);
            }
            continue;
          } else if (mode.type === "function") {
            const maybeFunctionName = mode.toolCall.function.name;
            if (maybeFunctionName) {
              functionCallName = maybeFunctionName;
            }
            const maybeArguments = mode.toolCall.function.arguments;
            if (mode.toolCall.function.arguments) {
              functionCallArguments += maybeArguments;
            }
            if (!executeThisFunctionCall) {
              if (functionCallName in functionsByName) {
                executeThisFunctionCall = true;
              }
            }
            mode.toolCall.function.scope = executeThisFunctionCall ? "server" : "client";
            writeChatCompletionChunk(controller, value);
            continue;
          }
        } catch (error) {
          controller.error(error);
          return;
        }
      }
    },
    cancel() {
      reader.cancel();
    }
  });
}
var SingleChunkReadableStream = class extends ReadableStream {
  constructor(content = "", toolCalls) {
    super({
      start(controller) {
        const chunk = {
          choices: [
            {
              delta: {
                role: "assistant",
                content,
                ...toolCalls ? { tool_calls: toolCalls } : {}
              }
            }
          ]
        };
        writeChatCompletionChunk(controller, chunk);
        writeChatCompletionEnd(controller);
        controller.close();
      },
      cancel() {
      }
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SingleChunkReadableStream,
  copilotkitStreamInterceptor
});
//# sourceMappingURL=stream.js.map